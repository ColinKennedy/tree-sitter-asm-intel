==============================================================================
simplified hello world
==============================================================================

; in `hello.asm`

        global _start

        section .text

_start: mov rdi, 1      ; stdout fd
        mov rsi, msg
        mov rdx, 9      ; 8 chars + newline
        mov rax, 1      ; write syscall
        syscall

        xor rdi, rdi    ; return code 0
        mov rax, 60     ; exit syscall
        syscall

        section .data

msg:    db "hi there", 10


-----------------------------------------------------------------------------

(program
  (comment)
  (instruction
    (mnemonic)
    (identifier))
  (instruction
    (mnemonic)
    (identifier))
  (label)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (identifier))
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic))
  (instruction
    (mnemonic)
    (register)
    (register))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic))
  (instruction
    (mnemonic)
    (identifier))
  (label)
  (instruction
    (mnemonic)
    (string)
    (integer)))


==============================================================================
sample hello world - NASM
==============================================================================

section .text
extern  _MessageBoxA@16
%if     __NASM_VERSION_ID__ >= 0x02030000
safeseh handler         ; register handler as "safe handler"
%endif

handler:
        push    dword 1 ; MB_OKCANCEL
        push    dword caption
        push    dword text
        push    dword 0
        call    _MessageBoxA@16
        sub     eax,1   ; incidentally suits as return value
                        ; for exception handler
        ret

global  _main
_main:  push    dword handler
        push    dword [fs:0]
        mov     dword [fs:0], esp
        xor     eax,eax
        mov     eax, dword[eax]   ; cause exception
        pop     dword [fs:0]      ; disengage exception handler
        add     esp, 4
        ret

avx2:   vzeroupper
        push      rbx
        mov       rbx,   rsp
        sub       rsp,   0h20
        vmovdqa   ymm0,  [rcx]
        vpaddb    ymm0,  [rdx]
        leave
        ret

text:   db      'OK to rethrow, CANCEL to generate core dump',0
caption:db      'SEGV',0

section .drectve info
        db      '/defaultlib:user32.lib /defaultlib:msvcrt.lib '

-----------------------------------------------------------------------------

(program)


==============================================================================
mixed hello world
==============================================================================

;Copyright (c) 1999 Konstantin Boldyshev <konst@linuxassembly.org>
;
;"hello, world" in assembly language for Linux
;
;to build an executable:
;       nasm -f elf hello.asm
;       ld -s -o hello hello.o

section .text
; Export the entry point to the ELF linker or loader.  The conventional
; entry point is "_start". Use "ld -e foo" to override the default.
    global _start

section .data
msg db  'Hello, world!',0xa ;our dear string
len equ $ - msg         ;length of our dear string

section .text

; linker puts the entry point here:
_start:

; Write the string to stdout:

    mov edx,len ;message length
    mov ecx,msg ;message to write
    mov ebx,1   ;file descriptor (stdout)
    mov eax,4   ;system call number (sys_write)
    int 0x80    ;call kernel

; Exit via the kernel:

    mov ebx,0   ;process' exit code
    mov eax,1   ;system call number (sys_exit)
    int 0x80    ;call kernel - this interrupt won't return


-----------------------------------------------------------------------------

(program
  (comment)
  (comment)
  (comment)
  (comment)
  (comment)
  (comment)
  (comment)
  (instruction
    (mnemonic)
    (identifier))
  (comment)
  (comment)
  (instruction
    (mnemonic)
    (identifier))
  (instruction
    (mnemonic)
    (identifier))
  (instruction
    (mnemonic)
    (identifier)
    (string)
    (hexadecimal))
  (comment)
  (instruction
    (mnemonic)
    (identifier)
    (identifier)
    (identifier)
    (identifier))
  (comment)
  (instruction
    (mnemonic)
    (identifier))
  (comment)
  (label)
  (comment)
  (instruction
    (mnemonic)
    (register)
    (identifier))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (identifier))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (hexadecimal))
  (comment)
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (register)
    (integer))
  (comment)
  (instruction
    (mnemonic)
    (hexadecimal))
  (comment))
